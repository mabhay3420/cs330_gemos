#include <ulib.h>

int main(u64 arg1, u64 arg2, u64 arg3, u64 arg4, u64 arg5)
{

	// Array to store both read and write fds of the pipe.
	int fd[2];

	// Create pipe.
	int ret_code = pipe(fd);

	// Check for any error in pipe creation.
	if (ret_code < 0)
	{

		printf("Pipe allocation failed!!!\n");
		return -1;
	}
	// Expected result is 0.
	printf("%d\n", ret_code);

	// Process 1 writes 2000 bytes
	ret_code = write(fd[1], "04309935651163967458342673933452569557087592538805250754206189514978215596238139294468615925722893560465538627245076125558225361058889825444643139386012653179517158375522887211720442850668190170586707292059459286639200660496976337355784007016466509733598908271784503059740648249693799553433979484905130450368458100796630700144361908565838302932286671585582674291879597321574877288418052342048325283312993686280343799388026381509585356782626377754978433558334482606136697907737790513378041262469111132326702451489335972509895450721470187911170843107985826051806442519951195496610444217761958260735459856964712636997417985589018648199387191659402416907322616034337723338829252388908380176623365950080949449741491603595976864970500766620098119109097109619197064371900747830647014192585650434517109703245963837752192996015232862500861134396783602394097479783809522145606188531960287977665895814443995566264073183837318829809449428875071692972191506601114781580225674564940503638048940815471636543694455664888858773939283302950568604594698813094713085234586411872570937307538731105560468691718826076107034721146891532775944135812791623774591865894123433959276497634360843355143018785411589371924275398773700611985067802270484239732977431732937266830962267596679295755517742635543559215726708287470128492906425851522862297319071118347301850368437338386045646765636628420385580531921848640447899548239465108071936248551947693464723449129621967301510013283468267819074412659109406091900559663760280600049412114794390553927085551108765467046009418943583461254386068642850159901459775151237555769539722836628060196638921261502165377138514522299009234662068522442325963857939547966342923329272954877515242397489276378442957404933796474184622817405730593855716130907857360801454876087431480200886112982824088837142084118942493306376238208008408369368259875966219648990642790108719276416959380411937204783684082050670293137099913539232958932616048872989726993960874031610321681688090534237199168747080330906161368", 2000);
	if (ret_code < 0)
	{
		printf("Parent: Writing to the pipe is failed!!!\n");
		return -1;
	}
	// Expected return should be 2000
	printf("%d\n", ret_code);

	// read 1000 bytes
	char read_buffer[1001];
	ret_code = read(fd[0], read_buffer, 1000);
	if (ret_code < 0)
	{

		printf("Parent: Reading from the pipe is failed!!!\n");
		return -1;
	}
	// Expected return will be 1000 and buffer will be as given in the file output
	read_buffer[1000] = '\0';
	printf("%d\n", ret_code);
	printf("%s\n", read_buffer);

	// Create child.
	int pid = fork();
	if (pid < 0)
	{
		printf("Somehow not able ro create process!!!\n");
		exit(-1);
	}

	if (!pid)
	{ // Child code.

		// these values should be 3 and 4
		printf("%d\n", fd[0]);
		printf("%d\n", fd[1]);
		// Process 2 writes 2496 bytes
		ret_code = write(fd[1], "999706110808803629532062698089001426083062809038611464890039755552152885444892338405571523518163339413346520095140903608536718830677986820475944028978491968516896848373919993129449783408972927140519400220197175047516484303218925460805559752714538468092627761318779458086927340064456496360211044464576599214524640135306496985754092458990173085387195461896903865461493730921175532778704161982750243811454219848334936080791659956959720848583339964305137713035855783907680172971875027962048079579375760887457600408609198636036294622811387767741598046744389087151205275551448446859463545054444222132229567284604818227922411756884258025840345768911128674798678046044398117512518376601136730562017377633278266816881086646130021865624139740726479007988607784422520765362130651404615875256103213047260100356457542754951091639641564741588521310551345846357646889611458457963514166262734838753102813066943599721305589068591778370887208455280303340263822207512285456628070991659458227291784017859598410360829447372033583523263593860097700337424568574334428627912680067985124366606692804450953997378988459344461356155054180332959520259305547409850614463077010444064130954941681050182643230876752726341981472236981302347500323571143530212552985352536919771704436671605829826289014215791387720421053096220390574867252415641657703287769537069520531654492898469339714910476025824537842399215992048746243947378711031713177845393881811101551693449797649944776969629464621284321022181823322003441160397760808017116529691363114545934896269382402916350878732907255159340516197364514654201054994074930029527044463524994426273318843154183546416670541147526945279646154884123134848399494189187217647957736667606274414917417144900928412382033672559941342490879201878628446445197207610255149570494006637644622156777178153798903925722158243807217015043535993539137732441528295517870774155741272464420479748559595758431667016430129475206151827358581990933878863546513589522602137918606232623867461813989646735700391814261609246588130851543132153602314290453755717936084961974283261668943347970308582389990444731292756960497109433873104513389824053489879991594471683543756118037715437886134327436228618662077998256476242033617533730028173866855485712487807841137980675942798923264236359354492723589970293749706055770173170639702734823113297587351646797777811440261993046006187068293651001527559308969914609678377837392349882437590086697405580522955021506209059162698391328590266773510887777794840130402031722723360029558849694", 2496);
		if (ret_code < 0)
		{
			printf("Child: Writing to the pipe is failed!!!\n");
			return -1;
		}
		// Expected return should be 2496
		printf("%d\n", ret_code);
		sleep(5);

		// Close both read and write ends.
		// Expected results should be 0.
		printf("%d\n", close(fd[0]));
		printf("%d\n", close(fd[1]));

		// Exit.
		exit(1);
	}

	// This is for order between parent and child.
	sleep(30);
	// process 1 reads 3296 bytes
	char read_buffer2[3297];
	ret_code = read(fd[0], read_buffer2, 3296);
	if (ret_code < 0)
	{

		printf("Parent: Reading from the pipe is failed!!!\n");
		return -1;
	}
	// Expected return will be 3296 and buffer will be as in the output
	read_buffer2[3296] = '\0';
	int j = 0;
	char read_part1[1001];
	while (j < 1000)
	{
		read_part1[j] = read_buffer2[j];
		j++;
	}
	read_part1[1000] = '\0';
	char read_part2[1001];
	while (j < 2000)
	{
		read_part2[j - 1000] = read_buffer2[j];
		j++;
	}
	read_part2[1000] = '\0';
	char read_part3[1001];
	while (j < 3000)
	{
		read_part3[j - 2000] = read_buffer2[j];
		j++;
	}
	read_part3[1000] = '\0';
	char read_part4[1001];
	while (j < 3296)
	{
		read_part4[j - 3000] = read_buffer2[j];
		j++;
	}
	read_part4[j - 3000] = '\0';
	printf("%d\n", ret_code);
	printf("%s\n", read_part1);
	printf("%s\n", read_part2);
	printf("%s\n", read_part3);
	printf("%s\n", read_part4);
	// printf("%s\n",read_buffer2);

	ret_code = read(fd[0], read_buffer2, 0);
	if (ret_code < 0)
	{

		printf("Parent: Reading from the pipe is failed!!!\n");
		return -1;
	}
	// Close pipe ends.
	// expected return will be 0.
	printf("%d\n", close(fd[0]));
	printf("%d\n", close(fd[1]));

	// Simple return.
	return 0;
}
